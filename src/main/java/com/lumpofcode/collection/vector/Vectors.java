package com.lumpofcode.collection.vector;

import com.lumpofcode.annotation.NotNull;
import com.lumpofcode.collection.iterable.FilteredIterator;

import java.util.Iterator;
import java.util.function.Function;
import java.util.function.Predicate;


/*--- Generated by com.lumpofcode.collection.vector.VectorTemplate ---*/

/**
* Methods that create or act on Vectors.
*
* Use the Vectors.asVector() functions to construct Vectors.
*
* Created by emurphy on 6/16/17.
*/
public final class Vectors
{
	/**
	 * Push all elements in the Iterable onto the end of the Vector
	 *
	 * @param vector Vector to be appended to
	 * @param iterable Iterable with elements to append
	 * @param <T> type of elements in the Vector and Iterable
	 * @return a new Vector with the Iterable's elements appended.
	 */
	public static final <T> Vector<T> appendAll(final Vector vector, final Iterable<T> iterable)
	{
		return Vectors.appendAll(vector, iterable.iterator());
	}

	/**
	 * Push all elements in the Iterator onto the end of the Vector
	 *
	 * @param vector Vector to be appended to
	 * @param it Iterator with elements to append
	 * @param <T> type of elements in the Vector and Iterator
	 * @return a new Vector with the Iterator's elements appended.
	 */
	public static final <T> Vector<T> appendAll(final Vector vector, final Iterator<T> it)
	{
		//
		// do in chunks of node size for efficiency
		//
		Vector<T> result = vector;

		//
		// get to a node-size-aligned result, so we can start using append-16 for efficiency
		//
		while(((result.size() % Vector.VECTOR_NODE_SIZE) != 0) && it.hasNext())
		{
			result = result.append(it.next());
		}

		//
		// While we have 16 elements available, collect them and use the more efficient 16 append,
		// otherwise append each element individually
		//
		while(it.hasNext())
		{
			final T e0 = it.next();
			if (it.hasNext())
			{
				final T e1 = it.next();
				if (it.hasNext())
				{
					final T e2 = it.next();
					if (it.hasNext())
					{
						final T e3 = it.next();
						if (it.hasNext())
						{
							final T e4 = it.next();
							if (it.hasNext())
							{
								final T e5 = it.next();
								if (it.hasNext())
								{
									final T e6 = it.next();
									if (it.hasNext())
									{
										final T e7 = it.next();
										if (it.hasNext())
										{
											final T e8 = it.next();
											if (it.hasNext())
											{
												final T e9 = it.next();
												if (it.hasNext())
												{
													final T e10 = it.next();
													if (it.hasNext())
													{
														final T e11 = it.next();
														if (it.hasNext())
														{
															final T e12 = it.next();
															if (it.hasNext())
															{
																final T e13 = it.next();
																if (it.hasNext())
																{
																	final T e14 = it.next();
																	if (it.hasNext())
																	{
																		//
																		// we have enough for a node size append
																		//
																		final T e15 = it.next();
																		result = result.append(e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15);
																	}
																	else
																	{
																		//
																		// else we don't have enough for a append of node size, so do a series of append of 1
																		//
																		result = result.append(e0).append(e1).append(e2).append(e3).append(e4).append(e5).append(e6).append(e7).append(e8).append(e9).append(e10).append(e11).append(e12).append(e13).append(e14);
																	}
																}
																else
																{
																	//
																	// else we don't have enough for a append of node size, so do a series of append of 1
																	//
																	result = result.append(e0).append(e1).append(e2).append(e3).append(e4).append(e5).append(e6).append(e7).append(e8).append(e9).append(e10).append(e11).append(e12).append(e13);
																}
															}
															else
															{
																//
																// else we don't have enough for a append of node size, so do a series of append of 1
																//
																result = result.append(e0).append(e1).append(e2).append(e3).append(e4).append(e5).append(e6).append(e7).append(e8).append(e9).append(e10).append(e11).append(e12);
															}
														}
														else
														{
															//
															// else we don't have enough for a append of node size, so do a series of append of 1
															//
															result = result.append(e0).append(e1).append(e2).append(e3).append(e4).append(e5).append(e6).append(e7).append(e8).append(e9).append(e10).append(e11);
														}
													}
													else
													{
														//
														// else we don't have enough for a append of node size, so do a series of append of 1
														//
														result = result.append(e0).append(e1).append(e2).append(e3).append(e4).append(e5).append(e6).append(e7).append(e8).append(e9).append(e10);
													}
												}
												else
												{
													//
													// else we don't have enough for a append of node size, so do a series of append of 1
													//
													result = result.append(e0).append(e1).append(e2).append(e3).append(e4).append(e5).append(e6).append(e7).append(e8).append(e9);
												}
											}
											else
											{
												//
												// else we don't have enough for a append of node size, so do a series of append of 1
												//
												result = result.append(e0).append(e1).append(e2).append(e3).append(e4).append(e5).append(e6).append(e7).append(e8);
											}
										}
										else
										{
											//
											// else we don't have enough for a append of node size, so do a series of append of 1
											//
											result = result.append(e0).append(e1).append(e2).append(e3).append(e4).append(e5).append(e6).append(e7);
										}
									}
									else
									{
										//
										// else we don't have enough for a append of node size, so do a series of append of 1
										//
										result = result.append(e0).append(e1).append(e2).append(e3).append(e4).append(e5).append(e6);
									}
								}
								else
								{
									//
									// else we don't have enough for a append of node size, so do a series of append of 1
									//
									result = result.append(e0).append(e1).append(e2).append(e3).append(e4).append(e5);
								}
							}
							else
							{
								//
								// else we don't have enough for a append of node size, so do a series of append of 1
								//
								result = result.append(e0).append(e1).append(e2).append(e3).append(e4);
							}
						}
						else
						{
							//
							// else we don't have enough for a append of node size, so do a series of append of 1
							//
							result = result.append(e0).append(e1).append(e2).append(e3);
						}
					}
					else
					{
						//
						// else we don't have enough for a append of node size, so do a series of append of 1
						//
						result = result.append(e0).append(e1).append(e2);
					}
				}
				else
				{
					//
					// else we don't have enough for a append of node size, so do a series of append of 1
					//
					result = result.append(e0).append(e1);
				}
			}
			else
			{
				//
				// else we don't have enough for a append of node size, so do a series of append of 1
				//
				result = result.append(e0);
			}
		}

		return result;
	}

	/**
	 * Filter elements in the Vector to create a new Vector
	 * composed of those that pass the filter
	 *
	 * @param vector Vector to be filtered
	 * @return a new Vector with elements that pass the predicate filter.
	 */
	public static final <T> Vector<T> filter(final Vector<T> vector, Predicate<T> predicate)
	{
		return Vectors.appendAll(Vector.empty, new FilteredIterator(vector.iterator(), predicate));
	}

	/**
	 * Filter elements in the Iterable and append those that pass the filter to the end of the Vector
	 *
	 * @param vector Vector that will be appended to
	 * @param iterable Iterable with elements to be filtered
	 * @param <T> type of elements in vector and iterable
	 * @return a new Vector with the Iterable's filtered elements appended.
	 */
	public static final <T> Vector<T> filter(final Vector<T> vector, final Iterable<T> iterable, Predicate<T> predicate)
	{
		return Vectors.appendAll(vector, new FilteredIterator(iterable.iterator(), predicate));
	}

	/**
	 * Map the values in the vector using the mapper function
	 * and return a new vector of mapped elements.
	 *
	 * @param vector the vector to operate on
	 * @param <R> the resulting element type
	 * @param mapper function that maps a T to an R
	 * @return Vector of elements of type R
	 */
	public static <T, R> Vector<R> map(final @NotNull Vector<T> vector, final @NotNull Function<? super T, ? extends R> mapper)
	{
		//
		// do in chunks of node size for efficiency
		//
		Vector<R> result = Vector.empty;
		int index = 0;
		while(index <= (vector.size() - Vector.VECTOR_NODE_SIZE))
		{
			result = result.append(
				mapper.apply(vector.get(index + 0)), 	mapper.apply(vector.get(index + 1)), 	mapper.apply(vector.get(index + 2)), 	mapper.apply(vector.get(index + 3)), 
				mapper.apply(vector.get(index + 4)), 	mapper.apply(vector.get(index + 5)), 	mapper.apply(vector.get(index + 6)), 	mapper.apply(vector.get(index + 7)), 
				mapper.apply(vector.get(index + 8)), 	mapper.apply(vector.get(index + 9)), 	mapper.apply(vector.get(index + 10)), 	mapper.apply(vector.get(index + 11)), 
				mapper.apply(vector.get(index + 12)), 	mapper.apply(vector.get(index + 13)), 	mapper.apply(vector.get(index + 14)), 	mapper.apply(vector.get(index + 15)));
			index += Vector.VECTOR_NODE_SIZE;
		}

		//
		// handle the rest with simple append
		//
		while(index < vector.size())
		{
			result = result.append(mapper.apply(vector.get(index)));
			index += 1;
		}

		return result;
	}

	/**
	 * Map each element of type T of the vector to
	 * a Vector of type R, to produce a vector of vectors of type R,
	 * then flatten (append) that into a vector of type R.
	 *
	 * @param vector the vector to operate on
	 * @param <R> the resulting element type
	 * @param mapper function that maps a value of type T
	 *               to a Vector with elements of type R
	 * @return Vector of elements of type R
	 */
	public static <T, R> Vector<R> flatmap(final @NotNull Vector<T> vector, final @NotNull Function<T, Vector<R>> mapper)
	{
		Vector<R> result = Vector.empty;
		for(T element : vector)
		{
			result = result.appendAll(mapper.apply(element));
		}

		return result;
	}

	/**
	 * Format vectors as '[e0, e1, e2...]'
	 *
	 * @param vector
	 * @param <T>
	 * @return
	 */
	public static <T> String toString(final @NotNull Vector<T> vector)
	{
		final StringBuilder builder = new StringBuilder();
		builder.append('[');
		if(!vector.isEmpty())
		{
			builder.append(vector.get(0));
			for(int i = 1; i < vector.size(); i += 1)
			{
				builder.append(", ").append(vector.get(i));
			}
		}
		builder.append(']');
		return builder.toString();
	}

}


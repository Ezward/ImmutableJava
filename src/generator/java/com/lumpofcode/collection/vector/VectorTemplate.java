
package com.lumpofcode.collection.vector;

import java.io.IOException;
import java.io.Writer;
import java.util.HashMap;
import java.util.Map;

/**
 * Class to generate java source file for a Vector class of a given size.
 */
public final class VectorTemplate
{
	/**
	 * Generate java source for a vector class of a given size.
	 * This will write to the given writer.
	 *
	 * To create a string, supply a new StringWriter(),
	 * the when generate finishes, get the string from
	 * the writer.
	 *
	 * @param writer a Writer that gets the vector source.
	 * @param size the size of the vector 1..nodeSize
	 */
	public void generateVector(final Writer writer, final int size, final int nodeSize)
	{
		if(nodeSize <= 0) throw new IllegalArgumentException();
		if((size <= 0) || (size > nodeSize)) throw new IllegalArgumentException();
		
		final VectorBuilder build = new VectorBuilder(writer);
		final Macros m = new Macros();
		
		//
		// set up common symbols
		//
		m.with("size", size);
		m.with("size-1", size - 1);
		m.with("size+1", size + 1);
		m.with("nodesize", nodeSize);
		
		//
		// package and imports
		//
		build.line("package com.lumpofcode.collection.vector.impl;").endLine();
		build.line("import com.lumpofcode.collection.vector.Vector;");
		build.line("import com.lumpofcode.collection.vector.Vectors;");
		build.line("import com.lumpofcode.collection.vector.VectorIterator;").endLine();
		build.line("import java.util.Iterator;");
		build.line("import java.util.function.Function;").endLine();
		
		
		build.endLine().line("/*--- Generated by com.lumpofcode.collection.vector.VectorTemplate ---*/").endLine();
		
		//
		// class definition
		//
		build.line(m.apply("public final class VectorOf{{size}}<T> implements Vector<T>, Iterable<T>"));
		build.beginBlock();
		{
			//
			// private properties for each element
			//
			for (int i = 0; i < size; i += 1)
			{
				build.line(m.with("i", i).apply("private final T element{{i}};"));
			}
			build.endLine();
			
			//
			// constructor
			//
			build.startLine("public VectorOf{{size}}".replace("{{size}}", String.valueOf(size)));
			build.startArgs();
			if (size > 0)
			{
				for (int i = 0; i < size - 1; i += 1)
				{
					build.arg(i, m.with("i", i).apply("T element{{i}}"));
				}
				build.arg(size - 1, m.apply("T element{{size-1}}"));
			}
			build.endArgs();
			build.endLine();
			
			// constructor body; assign each argument to corresponding property
			build.beginBlock();
			{
				for (int i = 0; i < size; i += 1)
				{
					build.line(m.with("i", i).apply("this.element{{i}} = element{{i}};"));
				}
			}
			build.endBlock();
			
			//
			// isEmpty() method
			//
			build.line("public boolean isEmpty() { return false; }").endLine();
			
			//
			// size() method
			//
			build.line(m.apply("public int size() { return {{size}}; }")).endLine();
			
			//
			// get() method
			//
			build.beginBlock("public T get(int index)");
			{
				build.beginBlock("switch(index)");
				{
					for (int i = 0; i < size; i += 1)
					{
						build.line(m.with("i", i).apply("case {{i}}: return element{{i}};"));
					}
					build.endBlock();
				}
				build.line("throw new IndexOutOfBoundsException();");
			}
			build.endBlock();
			
			//
			// set() method
			//
			build.beginBlock("public Vector<T> set(int index, T value)");
			{
				build.beginBlock("switch(index)");
				{
					for (int i = 0; i < size; i += 1)
					{
						build.startLine(m.with("i", i).apply("case {{i}}: return new VectorOf{{size}}<>"));
						build.startArgs();
						if (size > 0)
						{
							// use current values except for the index we are setting
							build.arg(0, (0 == i) ? "value" : "element0");
							for (int j = 1; j < size; j += 1)
							{
								build.arg(j, (i == j) ? "value" : m.with("j", j).apply("element{{j}}"));
							}
						}
						build.endArgs().endLine(";");
					}
					build.line(m.apply("case {{size}}: return push(value);"));
				}
				build.endBlock();
				
				build.line("throw new IndexOutOfBoundsException();");
			}
			build.endBlock();
			
			//
			// push() method
			//
			build.beginBlock("public Vector<T> push(T value)");
			{
				if (size < nodeSize)
				{
					build.startLine(m.apply("return new VectorOf{{size+1}}<>"));
					build.startArgs();
					for (int i = 0; i < size; i += 1)
					{
						m.with("i", i);
						build.arg(i, m.apply("element{{i}}"));
					}
					build.arg(size, "value");
					build.endArgs().endLine(";");
				}
				else
				{
					build.line("return new VectorTrie<>(1, this, new VectorOf1<>(value));");
				}
			}
			build.endBlock();
			
			//
			// push(e0..e15) method
			//
			// like for VectorOf5:
			//   return new VectorTrie<T>(
			//       1,
			//       new VectorOf16(element0, element1, element2, element3, element4, e0, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10),
			//       new VectorOf5(e11, e12, e13, e14, e15));
			//
			//
			//
			build.line("public Vector<T> push(T e0, T e1, T e2, T e3, T e4, T e5, T e6, T e7, T e8, T e9, T e10, T e11, T e12, T e13, T e14, T e15)");
			build.beginBlock();
			{
				build.startLine().startArgs("return new VectorTrie<T>");
				{
					build.arg(0, "1");
					build.arg(1, m.apply("new VectorOf{{nodesize}}")).startArgs();
					{
						for (int i = 0; i < size; i += 1)
						{
							m.with("i", i);
							build.arg(i, m.apply("element{{i}}"));
						}
						for (int i = 0, j = size; i < nodeSize - size; i += 1, j += 1)
						{
							m.with("i", i);
							build.arg(j, m.apply("e{{i}}"));
						}
					}
					build.endArgs();
					build.arg(2, m.apply("new VectorOf{{size}}")).startArgs();
					{
						for (int i = nodeSize - size, j = 0; i < nodeSize; i += 1, j += 1)
						{
							build.arg(j, m.with("i", i).apply("e{{i}}"));
						}
					}
					build.endArgs();
				}
				build.endArgs(";").endLine();
			}
			build.endBlock();
			
			
			//
			// pushAll() method
			//
			build.line("public Vector<T> pushAll(final Iterable<T> iterable)");
			build.beginBlock();
			{
				build.line("return Vectors.pushAll(this, iterable);");
			}
			build.endBlock();
			
			//
			// map() method
			//
			build.line("public <R> Vector<R> map(Function<? super T, ? extends R> mapper)");
			build.beginBlock();
			{
				build.startLine(m.apply("return new VectorOf{{size}}<>"));
				build.startArgs();
				for (int i = 0; i < size; i += 1)
				{
					m.with("i", i);
					build.arg(i, m.apply("mapper.apply(element{{i}})"));
				}
				build.endArgs();
				build.endLine(";");
			}
			build.endBlock();
			
			//
			// flatmap() method
			//
			build.line("public <R> Vector<R> flatmap(Function<T, Vector<R>> mapper)");
			build.beginBlock();
			{
				build.line("return Vectors.flatmap(this, mapper);");
			}
			build.endBlock();
			
			
			//
			// toString() method
			//
			build.line("public String toString()");
			build.beginBlock();
			{
				build.line("return Vectors.toString(this);");
			}
			build.endBlock();
			
			
			//
			// iterator() method
			//
			build.line("public Iterator<T> iterator() { return new VectorIterator<T>(this); }");
			
			
			//
			// close class
			//
		}
		build.endBlock();
	}
	
	public void generateVectorTrie(final Writer writer, final int nodeSize)
	{
		if(nodeSize <= 0) throw new IllegalArgumentException();
		
		final VectorBuilder build = new VectorBuilder(writer);
		final Macros m = new Macros();
		
		//
		// set up common symbols
		//
		m.with("nodesize", nodeSize);
		m.with("nodesize-1", nodeSize-1);
		
		//
		// package and imports
		//
		build.line("package com.lumpofcode.collection.vector.impl;").endLine();
		build.line("import com.lumpofcode.collection.vector.Vector;");
		build.line("import com.lumpofcode.collection.vector.Vectors;");
		build.line("import com.lumpofcode.collection.vector.VectorIterator;").endLine();
		build.line("import com.lumpofcode.math.IntegerMath;").endLine();
		build.line("import java.util.Iterator;").endLine();
		build.line("import java.util.function.Function;").endLine();
		
		build.endLine().line("/*--- Generated by com.lumpofcode.collection.vector.VectorTemplate ---*/").endLine();

		//
		// class declaration and private final properties
		//
		build.line("public final class VectorTrie<T> implements Vector<T>");
		build.beginBlock();
		{
			build.line(m.apply("private static final int VECTOR_NODE_SIZE = {{nodesize}};")).endLine();
			
			build.line("private final int level;        // zero if leaf node, 1 is first level trie, 2 is second level trie, etc.");
			build.line("private final int childSize;    // capacity (maximum size) of a child node at this level");

			build.line("private final int size;");
			for(int i = 0; i < nodeSize; i += 1)
			{
				m.with("i", i);
				build.line(m.apply("private final Vector<T> vector{{i}};"));
			}
			build.endLine();

			//
			// 2 vector constructor
			//
			build.line("public VectorTrie(final int level, final Vector<T> vector0, final Vector<T> vector1)");
			build.beginBlock();
			{
				build.startLine().startArgs("this");
				build.arg(0, "level").arg(1, "vector0").arg(2, "vector1");
				for(int i = 2; i < nodeSize; i += 1)
				{
					build.arg(i, "Vectors.empty");
				}
				build.endArgs().endLine(";");
			}
			build.endBlock();


			//
			// complete constructor
			//
			build.startLine().startArgs("public VectorTrie").arg(0, "final int level");
			for(int i = 0; i < nodeSize; i += 1)
			{
				m.with("i", i);
				build.arg(i + 1, m.apply("final Vector<T> vector{{i}}"));
			}
			build.endArgs().endLine();
			build.beginBlock();
			{
				build.line("this.level = level;");
				build.line("this.childSize = IntegerMath.power(VECTOR_NODE_SIZE, level);");
				
				//
				// initialize vector properties
				//
				for(int i = 0; i < nodeSize; i += 1)
				{
					m.with("i", i);
					build.line(m.apply("this.vector{{i}} = vector{{i}};"));
				}
				build.endLine();

				//
				// eager size calculation
				//
				build.startLine().openList().item(0, "this.size =  vector0.size()", "+ ");
				for(int i = 1; i < nodeSize; i += 1)
				{
					m.with("i", i);
					build.item(i, m.apply("vector{{i}}.size()"), " + ");
				}
				build.endLine(";");
			}
			build.endBlock();

			//
			// size()
			//
			build.line("public int size()");
			build.beginBlock();
			{
				build.line("return this.size;");
			}
			build.endBlock();

			//
			// isEmpty()
			//
			build.line("public boolean isEmpty()");
			build.beginBlock();
			{
				build.line("return false;");
			}
			build.endBlock();

			//
			// get() method()
			//
			build.line("public T get(final int index)");
			build.beginBlock();
			{
				build.line("if((index < 0) || (index >= size())) throw new IndexOutOfBoundsException();");
				build.endLine();
				build.line("//");
				build.line("// find the child within this trie (index / childSize)");
				build.line("// then get that child's element (index % childSize)");
				build.line("//");
				build.line("return getChild(index / childSize).get(index % childSize);");
			}
			build.endBlock();

			//
			// set() method
			//
			build.line("public Vector<T> set(final int index, final T value)");
			build.beginBlock();
			{
				build.line("if((index < 0) || (index > size())) throw new IndexOutOfBoundsException();");
				build.endLine();
				build.line("//");
				build.line("// find the child within this trie (index / childSize)");
				build.line("// if it is within this trie, set it's element (index % childIndex)");
				build.line("// if it is not within this trie, then we need to add another level to the hierarchy");
				build.line("//");
				build.line("final int childIndex = index / childSize;");
				build.line("if(childIndex < VECTOR_NODE_SIZE)");
				build.beginBlock();
				{
					build.line("//");
					build.line("// find the child within this trie (index / childSize)");
					build.line("// then set that child's element (index % childSize)");
					build.line("// and build a new vector using the updated child");
					build.line("//");
					build.line("return setChild(childIndex, getChild(childIndex).set(index % childSize, value));");
				}
				build.endBlock();
				
				build.line("//");
				build.line("// we are beyond the capacity of this trie, so create a new level in the hierarachy");
				build.line("//");
				build.line("return new VectorTrie(level + 1,this, Vectors.asVector(value));");
			}
			build.endBlock();

			//
			// push() method
			//
			build.line("public Vector<T> push(final T value)");
			build.beginBlock();
			{
				build.line("// add element after last current element");
				build.line("return this.set(this.size(), value);");
			}
			build.endBlock();

			//
			// push(e1..e16) method
			//
			build.startLine("public Vector<T> push");
			build.startArgs();
			for(int i = 0; i < nodeSize; i += 1)
			{
				m.with("i", i);
				build.arg(i, m.apply("final T e{{i}}"));
			}
			build.endArgs();
			build.beginBlock();
			{
				build.line("final int childIndex = size / childSize; // index of vector containing last element");
				build.line("final int childCount = size % childSize;  // size of vector containing last element");
				build.line("final int childCapacity = childSize - childCount;   // remaining capacity of vector containing last element");
				build.endLine();
				
				build.line("//");
				build.line("// determine if we can just add this to the child, or if we need to split it between children");
				build.line("//");
				build.line(m.apply("if(childCapacity >= {{nodesize}})"));
				build.beginBlock();
				{
					build.line("if(childIndex < VECTOR_NODE_SIZE)");
					build.beginBlock();
					{
						build.line("//");
						build.line("// there is room for these elements in the child,");
						build.line("// push to the child, then rebuild the trie with the updated child");
						build.line("//");
						build.startLine("return setChild(childIndex, getChild(childIndex).push");
						build.startArgs();
						for(int i = 0; i < nodeSize; i += 1)
						{
							build.arg(i, m.with("i", i).apply("e{{i}}"));
						}
						build.endArgs();
						build.endLine(");");
					}
					build.endBlock();
					
					build.line("//");
					build.line("// no room in this level of the hierarchy, so create another level");
					build.line("//");
					build.startLine("return new VectorTrie<T>(this.level + 1, this, Vectors.asVector");
					build.startArgs();
					//(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16));
					for(int i = 0; i < nodeSize; i += 1)
					{
						build.arg(i, m.with("i", i).apply("e{{i}}"));
					}
					build.endArgs().endLine(");");
				}
				build.endBlock();
				build.line("else");
				build.beginBlock();
				{
					build.line("//");
					build.line("// there is not enough room in the child for 16 elements, which means these");
					build.line("// new elements will need to be split between children.");
					build.line("// Use a loop to push each element.  It is inefficient, but handles situation");
					build.line("// where a new child or new level in the hierarchy is required");
					build.line("//");
					build.startLine("return this");
					for(int i = 0; i < nodeSize; i += 1)
					{
						build.emit(m.with("i", i).apply(".push(e{{i}})"));
					}
					build.endLine(";");
				}
				build.endBlock();
			}
			build.endBlock();


			//
			// pushAll() method
			//
			build.line("public Vector<T> pushAll(final Iterable<T> iterable)");
			build.beginBlock();
			{
				build.line("return Vectors.pushAll(this, iterable);");
			}
			build.endBlock();


			//
			// map() method
			//
			build.line("public <R> Vector<R> map(final Function<? super T, ? extends R> mapper)");
			build.beginBlock();
			{
				build.startLine("return new VectorTrie<R>").startArgs();
				build.arg(0, "level");
				for(int i = 0; i < nodeSize; i += 1)
				{
					build.arg(i + 1, m.with("i", i).apply("vector{{i}}.map(mapper)"));
				}
				build.endArgs().endLine(";");
			}
			build.endBlock();

			//
			// flatmap() method
			//
			build.line("public <R> Vector<R> flatmap(final Function<T, Vector<R>> mapper)");
			build.beginBlock();
			{
				build.line("Vector<R> result = Vectors.empty;");
				for(int i = 0; i < nodeSize; i += 1)
				{
					m.with("i", i);
					build.line(m.apply("result = result.pushAll(vector{{i}}.flatmap(mapper));"));
				}
				build.line("return result;");
			}
			build.endBlock();

			//
			// toString() method
			//
			build.line("public String toString()");
			build.beginBlock();
			{
				build.line("return Vectors.toString(this);");
			}
			build.endBlock();

			//
			// iterator() method
			//
			build.line("public Iterator<T> iterator()");
			build.beginBlock();
			{
				build.line("return new VectorIterator<T>(this);");
			}
			build.endBlock();

			build.line("//");
			build.line("// ---------------------- private helpers --------------------------");
			build.line("//");
			
			build.line("/**");
			build.line(" * get child vector at given child index");
			build.line(" * ");
			build.line(" * @param childIndex index of child vector 0..VECTOR_NODE_SIZE-1");
			build.line(" * @return child vector given child index   ");
			build.line(" */");
			build.line("private Vector<T> getChild(final int childIndex)");
			build.beginBlock();
			{
				build.line("if((childIndex < 0) || (childIndex >= VECTOR_NODE_SIZE)) throw new IndexOutOfBoundsException();");
				build.line("switch(childIndex)");
				build.beginBlock();
				{
					for(int i = 0; i < nodeSize - 1; i += 1)
					{
						build.line(m.with("i", i).apply("case {{i}}: return vector{{i}};"));
					}
					build.line(m.apply("default: return vector{{nodesize-1}};"));
				}
				build.endBlock();
			}
			build.endBlock();

			//
			// setChild() method
			//
			build.line("/**");
			build.line(" * set child element at given index to the given vector");
			build.line(" * ");
			build.line(" * @param childIndex index of child vector 0..VECTOR_NODE_SIZE-1");
			build.line(" * @param childValue child vector");
			build.line(" * @return new vector with given child at given index   ");
			build.line(" */");
			build.line("private Vector<T> setChild(final int childIndex, Vector<T> childValue)");
			build.beginBlock();
			{
				build.line("if((childIndex < 0) || (childIndex >= VECTOR_NODE_SIZE)) throw new IndexOutOfBoundsException();");
				build.line("switch(childIndex)");
				build.beginBlock();
				{
					for(int i = 0; i < nodeSize; i += 1)
					{
						m.with("i", i);
						build.startLine((i == nodeSize - 1) ? "default: " : m.apply("case {{i}}: ")).emit("return new VectorTrie(level");
						for(int j = 0; j < nodeSize; j += 1)
						{
							m.with("j", j);
							build.emit(", ").emit((i == j) ? "childValue" : m.apply("vector{{j}}"));
						}
						build.endLine(");");
					}
				}
				build.endBlock();
			}
			build.endBlock();
		}
		build.endBlock();
	}
	
	private String vectorOfSize(final int size)
	{
		return "VectorOf{{size}}".replace("{{size}}", String.valueOf(size));
	}
	
	/**
	 * simplistic symbol table for macro processing
	 */
	private static class Macros
	{
		final Map<String, String> symbols = new HashMap<>();
		
		public Macros with(final String symbol, final String value)
		{
			symbols.put(symbol, value);
			return this;
		}
		public Macros with(final String symbol, final int value)
		{
			return with(symbol, String.valueOf(value));
		}
		public Macros unset(final String symbol)
		{
			symbols.remove(symbol);
			return this;
		}
		
		public String apply(final String string)
		{
			String fixed = string;
			for(String symbol : symbols.keySet())
			{
				fixed = fixed.replace("{{" + symbol + "}}", symbols.get(symbol));
			}
			return fixed;
		}
	}
	
	
	private static class VectorBuilder
	{
		private final Writer builder;
		private int blockFrame = 0; // for balancing block open and close
		private int listFrame = 0;  // for balancing list open and close
		private final Map<String, String> values = new HashMap<>();
		
		/**
		 * Construct with given builders (allows appending or prepending)
		 *
		 * @param builder
		 */
		public VectorBuilder(final Writer builder)
		{
			this.builder = builder;
		}
		
		//
		// emit arbitrary text
		//
		public VectorBuilder emit(final String string)
		{
			try
			{
				builder.write(string);
			}
			catch (IOException e)
			{
				throw new RuntimeException(e);
			}
			
			return this;
		}
		public VectorBuilder emit(final char c)
		{
			try
			{
				builder.write(c);
			}
			catch (IOException e)
			{
				throw new RuntimeException(e);
			}
			
			return this;
		}
		
		//
		// line with proper indentation and new line at end
		//
		public VectorBuilder line(final String string)
		{
			return startLine().emit(string).endLine();
		}
		
		private VectorBuilder startLine()
		{
			return tabs(blockFrame);
		}
		private VectorBuilder startLine(final String string)
		{
			return startLine().emit(string);
		}
		
		public VectorBuilder endLine()
		{
			return emit('\n');
		}
		public VectorBuilder endLine(final String string)
		{
			return emit(string).endLine();
		}
		
		//
		// arbitrary tabs
		//
		public VectorBuilder tab()
		{
			return emit('\t');
		}
		
		public VectorBuilder tabs(final int count)
		{
			for(int i = 0; i < count; i += 1)
			{
				emit('\t');
			}
			
			return this;
		}
		
		//
		// {} block
		//
		public VectorBuilder beginBlock(final String string)
		{
			return line(string).beginBlock();
		}
		public VectorBuilder beginBlock()
		{
			line("{");
			blockFrame += 1;
			return this;
		}
		
		public VectorBuilder endBlock()
		{
			if(blockFrame <= 0) throw new IllegalStateException();
			blockFrame -= 1;
			return line("}").endLine();
		}
		
		//
		// argument list
		//
		public VectorBuilder startArgs()
		{
			return openList("(");
		}
		public VectorBuilder startArgs(final String prepend)
		{
			return emit(prepend).openList("(");
		}
		public VectorBuilder arg(final int argNumber, final String arg)
		{
			return item(argNumber, arg, ", ");
		}
		public VectorBuilder endArgs()
		{
			return closeList(")");
		}
		public VectorBuilder endArgs(final String append)
		{
			return closeList(")").emit(append);
		}
		
		//
		// bracketed, delimited list
		//
		public VectorBuilder openList()
		{
			return openList("");
		}
		public VectorBuilder openList(final String openBracket)
		{
			listFrame += 1;
			return ((null != openBracket) && !openBracket.isEmpty()) ? emit(openBracket) : this;
		}
		public VectorBuilder item(final int argNumber, final String arg, final String delimiter)
		{
			// if arg count > 0, then prepend with a comma
			if(argNumber > 0)
			{
				emit(delimiter);
			}
			return emit(arg);
		}
		public VectorBuilder closeList()
		{
			return closeList("");
		}
		public VectorBuilder closeList(final String closeBracket)
		{
			if(listFrame <= 0) throw new IllegalStateException();  // more endArgs than startArgs!
			if((null != closeBracket) && !closeBracket.isEmpty()) emit(closeBracket);
			listFrame -= 1;
			return this;
		}
	}
	
	
	
}
